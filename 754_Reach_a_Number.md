# 754. Reach a Number

You are standing at position 0 on 
You are standing at position `0` on an infinite number line. There is a destination at position `target`.

You can make some number of moves numMoves so that:
On each move, 
- you can either go left or right.
- During the ith move (starting from `i` == 1 to `i` == numMoves), you take `i` steps in the chosen direction.

Given the integer `target`, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.
```
Example 1:

Input: target = 2
Output: 3
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to -1 (2 steps).
On the 3rd move, we step from -1 to 2 (3 steps).

Example 2:

Input: target = 3
Output: 2
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to 3 (2 steps).
```

### Restating the problem
Find smallest N s.t. `+/- 1 +/- 2 +/- 3 +/- ... +/- N = target`

### Fact 1
Every subset of `[1, n]` and their element-wise sums is mapped to every integer in `[0, T(n)]`, where
`T(n) = 1 + 2 + 3 + ... + n = (n^2 + n) / 2`.
```
[1, 2, 3]
0 = sum([])
1 = sum([1])
2 = sum([2])
3 = sum([3])
4 = sum([1, 3])
5 = sum([2, 3])
6 = sum([1, 2, 3])
```
_Proof_

Proof by induction, suppose this is true for `n = k`. There are exactly k+1 numbers between T(k) and T(k+1)

```T(k) + 1, T(k) + 2, ..., T(k) + k + 1 = T(k+1)```. 
- To make T(k) + 1, we `sum([1, 2, ..., k-1, k+1])`.
- To make T(k) + 2, we `sum([1, 2, ..., k-2, k, k+1])`.
- ...
- To make T(k) + k, we `sum([2, ..., k, k+1])`.
- To make T(k) + k + 1, we `sum([1, 2, ..., k, k+1])`.

`T(k) + k + 1 = T(k+1)` is the maximum sum of each of the subset in `[1, k+1]`, and each sum of each subset of `[1, k+1]` is mapped to every number in `[0, T(k+1)]`

Therefore Fact 1 is true for `n = k + 1`.
Fact 1 is true for `n = 1`, Fact 1 is true for `n >= 1` by induction.

### Fact 2
Numbers of the form `+/- 1 +/- 2 +/- 3 +/- ... +/- N` are mapped to:
- every even integer in `[-T(N), T(N)]` if `T(N)` is even.
- every odd integer in `[-T(N), T(N)]` if `T(N)` is odd.
```
e.g.
0, 2, 4, 6, -6, -4, -2 for N = 3
-3, -1, 1, 3 for N = 2
```
_Proof_
```
T(N) = 1 + 2 + ... + N

wlog [a_1, a_2, ... a_k] is a subset of [1, N]

T(N) - 2(a_1 + a_2 + ... + a_k) = 1 + 2 + ... + N - 2(a_1 + a_2 + ... + a_k)

K = sum([a_1, a_2, ... a_k])
K in [0, T(N)] by Fact 1

Every +/- 1 +/- 2 +/- ... +/- N can be generated by choosing every subset [a_1, a_2, ... a_k] of [1, N]
T(N) - 2K = +/- 1 +/- 2 +/- ... +/- N

T(N) - 2K is in [-T(N), T(N)]

T(N) - 2K is odd if T(N) is odd
T(N) - 2K is even if T(N) is even
```

### When is T(n) even or odd?
- T(n) is even if n is `3 mod 4` or `0 mod 4`.
- T(n) is odd if n is `1 mod 4` or `2 mod 4`.
  
This can be easily verified.

### Original Problem
Find integer `n` such that `T(n) >= abs(target)`:
```
n >= ceil( sqrt(2 * target + 0.25) - 0.5 )
```
If `target` is even, find the smallest `a >= n` such that `T(a)` is even, and by Fact 2, numbers in the form `+/- 1 +/- 2 +/- ... +/- a` will include `target`. T(x) is monotonically increasing so `a` is guaranteed to be the minimum.
Vice versa for if `target` is odd.

This should be a constant time solution.

### Code
```python
class Solution:
    def reachNumber(self, target: int) -> int:
        import math
        target = abs(target)
        n = math.ceil((target * 2 + 0.25) ** 0.5 - 0.5)

        if target % 2 == 0:
            return n + [0, 2, 1, 0][n % 4]

        else:
            return n + [1, 0, 0, 2][n % 4]
```
